---
layout: post
title:  "[2018 BISI-A] 코드론을 활용한 드론 자율 비행"
date:   2019-08-31 18:43:59
author: BISI-A
categories: BISI-A
tags:	BISI BISI-A CoDrone_Autopilot
cover:  "/assets/instacode.png"
---
## 1. 원리

### 1.1 양력
양력은 말 그대로 기체를 위로 띄우는 힘을 말한다. 양력을 발생시키는 방법은 매우 많이 있지만 그중 대표적으로 2가지 방법이 있다. 첫 번째로는 공기의 경로의 길이의 차이에 따른 압력의 차이로 고기압에서 저기압으로 공기가 흐르는 성질을 이용해 기체를 띄우는 방식이 있다. 다른 하나는 날개를 비틀어 주행 시에 공기가 날개의 아랫면을 치게 되면 이 힘에 대한 반작용으로 기체를 띄우는 방식이 있다. 첫 번째 경우는 보통 비행기와 같은 고정익 방식의 기체를 만들 때에 많이 사용되고 두 번째 경우는 보통 헬기와 같은 회전익 방식의 기체에 많이 사용된다. 드론도 헬기와 마찬가지로 회전익 방식의 기체이므로 두 번째의 양력을 발생시키는 방식이 주를 이룬다.

### 1.2 작용 반작용(뉴턴 제 3법칙)
작용, 반작용이란 힘이 작용할 때 그의 반대되는 방향으로(합력이 0이 되도록) 같은 크기의 힘이 작용하는 것을 말한다. 드론의 프로펠러는 대각선 방향을 한 쌍으로 두 쌍이 각각 반대 방향으로 회전한다. 그 이유는 만약 프로펠러가 시계방향으로만 회전한다면 이에 대한 반작용으로 기체는 시계 반대 방향으로 회전하게 된다. 이렇게 되면 기체를 제어할 수 없게 된다. 그렇기 때문에 대각선의 프로펠러가 한쌍을 이루어 쿼드콥터의 경우 2개는 CW, 2개는 CCW로 회전한다.

### 1.3 관성
관성이란 물체가 운동 상태를 유지하려는 성질을 말한다. 드론의 자율비행동작을 컨트롤 할 때에는 관성을 특히 신경 써야 한다. 지면에서 움직이는 물체와 달리 드론은 공중에 있어 공기와의 마찰 빼고는 항력이 거의 발생하지 않는다. 따라서 거의 외력이 없는 상황이나 마찬가지이므로 관성을 고려하지 않고 코딩을 하게 되면 자신이 원하는 방향으로 기체를 날리지 못한다. 따라서 운동 관성을 잘 제어하여 코딩을 하여야 한다.

## 2. 준비물
코드론, 노트북, 로킷 브릭 or 아두이노(robolink에서 배포한 버전으로 설치할 것)(robolinksw.com)

## 3. 실험 과정
### 3.1 로킷 브릭을 활용하여 코딩을 하는 방법
로킷 브릭은 스크래치를 기반으로 코드론의 비행을 제어할 수 있는 툴이다.
프로그램을 제어하는 방법은 공식 사이트를 방문하는 것이 더 정확하므로 아래 링크를 참고하면 된다.
[로킷 브릭 사용설명서](http://robolink.ipdisk.co.kr/publist/HDD1/download/file/20180110_codronepro_teaching_rokitbrick.pdf),
[코드론 공식 채널, 다양한 튜토리얼과 셋팅 방법이 있음](https://www.youtube.com/channel/UCNdFOiP—9jH4BS1q1Jzsag/videos)
### 3.2 아두이노를 활용하여 코딩을 하는 방법
코드론2에는 코드로더가 공식 판매를 하고 있지만 코드론 1은 작성하는 시점에도 스토어에서 찾아볼 수 없다. 따라서 이 부품은 로보링크에서 제공받아서 실험을 진행하였다. 아두이노 나노와 같은 ATmega328을 mcu로 사용하고 있다. 위에서 언급한 것과 같이 로보링크에서 배포하고 있는 아두이노를 통해 코딩을 할 수 있다. 아두이노의 코딩 방법은 기존 아두이노와 비슷하며 CodeLoader.h의 헤더파일에 있는 함수들을 사용하여 코드론의 움직임을 제어할 수 있다. 아래는 함수에 대한 설명이다.(기본적인 것만)

> CodeloaderBegin(int \_sec); - int안에 입력한 시간 경과 후 자동으로 착륙

> CoDroneClass::FlightEvent();  
  > CoDrone.FlightEvent(TakeOff); - 이륙(5초 정도 지속하는 것이 안정화에 도움이 됨)
  > CoDrone.FlightEvent(Landing); - 착륙
  
 >CoDroneClass::Control(); - 위에 입력한 Throttle, Pitch, Roll, Yaw 값을 드론에 전송
  >ex</br>
  pitch = 100;</br>
  CoDrone.Control();</br>
  delay(500);</br>

## 4. 결과
로킷 브릭을 활용하여 여러 장애물을 통과하고 원하는 경로로 드론을 비행시킬 수 있었다. 헬스용 손잡이를 넘어 목표된 지점에 착륙할 수 있었고 키보드 버튼을 활용하여 드론의 비행을 제어하는 코딩을 할 수 있었다. 또한 코드로더를 사용하여 조금 더 안정된 비행을 할 수 있었다. 통신 방식이 블루투스 대신 유선 Serial 통신을 하다 보니 통신 딜레이가 없어 조금 더 정확한 움직임이 가능했다. 블루투스를 활용하여 비행할 경우 다수의 드론이 함께 비행하는 경우 명령이 제대로 가지 않는 경우가 있었다.

## 5. 결론
코드론을 활용하여 드론의 동작을 다양하게 제어할 수 있었다. 또한 통신 칩의 드라이버 문제로 인식이 안되는 경우가 있었다. 그럴 경우 로보링크 홈페이지에서 배포하는 USB Helper를 다운받아 드라이버를 설치하여 실행하여 해결할 수 있었다. 처음에 호버링을 4초 이상 할 때 사용자가 원하는 동작을 가장 잘 수행하였다. 고도 센서와 영상 플로우 센서들을 사용하여 다양한 드론의 동작을 실행시킬 수 있었고 이를 활용하여 다양한 미션으 수행할 수 있었다. 또한 다수의 드론을 날리는 경우 로킷 브릭보다 아두이노를 활용하는 것이 더 수월한 제어가 가능했다.

## 6. 유의사항
### 6.1. 반드시 프로펠러 가드를 장착할 것
보통 코드론 자율비행은 실내에서 진행하는 것이 좋다. 코드론 1은 코드론 2에 비해 기체의 크기가 작고 모터의 출력도 작아 바람 등의 외부 영향을 많이 받을 수 밖에 없다. 그러다 보니 실내에서 사람과 가까운 거리에서 날려야 하는 상황이라면 드론이 외부의 어떠한 영향을 받아 사람 근처로 접근하거나 사람을 칠 지 모른다. 따라서 프로펠러 가드를 장착하는 것을 추천한다.
### 6.2. 드론이 비행하는 경로에는 사람이 있지 않도록 할 것
로킷 브릭은 그나마 괜찮지만 아두이노로 코딩하였을 경우 드론의 비행을 멈출 수 없다. 따라서 드론이 비행하는 공간 또는 그 주변에 있는다면 6.1에서 언급했던 것 처럼 드론이 사람에게 달려들 수 있다. 따라서 사람은 반드시 드론의 경로와는 멀리서 있을 것을 추천한다.
### 6.3. 바닥에 무늬를 만들어 줄 것
흔히 드론이 흐른다고 한다. 호버링 시 트림을 제대로 잡는다 해도 주변의 영향으로 인해서 드론이 제자리에 있기는 힘든 일이다. 그렇기 때문에 어느정도 이상의 성능을 가지고 있는 드론에는 옵티컬 플로우 센서가 탑재되어 있다. (옵티컬 플로우 센서의 원리는 1.4에서 볼 수 있다.) 옵티컬 플로우 센서는 바닥의 무늬를 바탕으로 작동하므로 바닥에 무늬를 만들어줄 것을 추천한다.
### 6.4. 작동이 잘 되지 않을 경우 캘리브레이션을 할 것
보통 옵티컬 플로우 센서와 자이로 센서, 트림 등 다수의 값이 드론에 저장된다. 만약 새로운 환경에서 드론을 사용한다면 드론이 한 번 위로 날면서 바닥의 패턴과 고도를 파악하고 자이로 센서를 리셋하므로서 새로운 환경에 다시 드론이 최적화 시킬 것이다. 따라서 동작이 제대로 되지 않을 경우 캘리브레이션을 먼저 해보는 것을 추천한다.
